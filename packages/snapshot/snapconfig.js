// @ts-check
'use strict'

const resolveFrom = require('resolve-from')
const path = require('path')
const platformString = process.platform

const runAgainstExperimentDirectory = process.env.RUN_AGAINST_EXPERIMENT_DIRECTORY != null

const snapshotCacheBaseDir = runAgainstExperimentDirectory ? path.resolve(__dirname, '../snapshot-performance-analysis/cache') : path.resolve(__dirname, './cache')

const projectBaseDir = path.join(__dirname, '../../')
const appEntryFile = runAgainstExperimentDirectory ? require.resolve('../snapshot-performance-analysis/deps/index.js') : require.resolve('../server/index.js')

// TODO(thlorenz): this is most likely different when creating prod artifacts
const cypressAppSnapshotDir = (() => {
  const electronPackageDir = path.join(projectBaseDir, 'packages/electron')

  let cypressApp
  let electronPath

  switch (platformString) {
    case 'darwin': {
      cypressApp = 'dist/Cypress/Cypress.app'
      electronPath = 'Contents/Frameworks/Electron Framework.framework/Versions/A/Resources/'
      break
    }
    case 'win32':
    case 'cygwin': {
      cypressApp = 'dist/Cypress'
      electronPath = ''
      break
    }

    // TODO(thlorenz): verify Linux location
    case 'linux':
      cypressApp = 'dist/Cypress'
      electronPath = ''
      break

    // TODO(thlorenz): verify BSD location
    case 'openbsd':
    case 'netbsd': {
      cypressApp = 'dist/Cypress'
      electronPath = ''
      break
    }

    case 'sunos':
      // TODO: Do we support sunos???
      // eslint-disable-next-line no-fallthrough
    default: {
      throw new Error(`Unable to determine Cypress App location for '${platformString}' platform.`)
    }
  }

  if (runAgainstExperimentDirectory) {
    const electron = path.dirname(resolveFrom(projectBaseDir, 'electron'))

    return path.join(
      electron,
      'dist/Electron.app/Contents/Frameworks/Electron Framework.framework/Versions/A/Resources',
    )
  }

  const cypressAppDir = path.join(electronPackageDir, cypressApp)

  return path.join(
    cypressAppDir,
    electronPath,
  )
})()

const pathsMapper = (s) => s.replace(/^packages\//, './packages/')

const usePreviousSnapshotMetadata = process.env.PACK_FROM_SCRATCH == null

const LOG_VERBOSE = '(snap|pack)*:(info|debug|warn|trace|error)'
const LOG_DEBUG = '(snap|pack)*:(info|debug|warn|error)'
const LOG_INFO = '(snap|pack)*:(info|warn|error)'

/**
 * @typedef {Object} SnapshotConfig          - Configuration for creating snapshots.
 *
 * @property {string} LOG_INFO               - logs only errors and highlevel snapshot related messages
 * @property {string} LOG_DEBUG,             - logs errors, highlevel and debug snapshot related messages
 * @property {string} LOG_VERBOSE            - logs all snapshot related messages
 * @property {string} appEntryFile           - the app entry file used to generate the, see snapshotEntryFile
 *
 * @property {string} cypressAppSnapshotDir  - the location from where the Cypress app loads the snapshot
 * @property {boolean} nodeModulesOnly       - if `true` then no application files are included in the snapshot
 * @property {Function} pathsMapper          - maps paths to work around edge cases
 * @property {string} projectBaseDir         - the base dir of the project being snapshotted
 *
 * @property {string} snapshotCacheDir       - directory where esbuild metadat, snapshot metadata
 *    and snapshot entry file are stored.
 *    This is different for prod vs. dev environments
 *
 * @property {string} snapshotEntryFile      - file used by esbuild to find all files to include in the snapshot.
 *    This file is generated via see lib/gen-entry.
 *
 * @property {string} snapshotMetaFile       - file used to determine which modules can be included in the snapshot
 * @property {string} snapshotMetaPrevFile   - previous determine metafile used as starting v8-snapshto starting point
 *   see usePreviousSnapshotMetadata
 *
 * @property {string} metaFile               -  file used to determine circular references and how to process modules
 *    when generating the snapshot.  This file is generated by esbuild via see lib/gen-meta.
 *
 * @property {boolean} usePreviousSnapshotMetadata - If true then health/deferred/norewrite data collected during
 *   a previous run of the snapshot doctor is used as a starting point.
 *  This speeds up the snapshot doctor step immensly, but should be turned off when a lot of
 *  dependencies changed and/or when creating a prod artifact.
 */

/**
 * Creates a snapshot config tailored to the provided environment.
 *
 * @param {string} env - 'dev' | 'prod'
 * @returns {SnapshotConfig} config to be used for all snapshot related tasks
 */
module.exports = function createConfig (env) {
  /**
   * If true only node_module dependencies are included in the snapshot, otherwise app files as well.
   *
   * Configured via `env`.
   */
  const nodeModulesOnly = env === 'dev'

  const snapshotCacheDir =
    env === 'dev'
      ? path.join(snapshotCacheBaseDir, `dev-${platformString}`)
      : path.join(snapshotCacheBaseDir, `prod-${platformString}`)

  const snapshotEntryFile = path.join(snapshotCacheDir, 'snapshot-entry.js')
  const metaFile = path.join(snapshotCacheDir, 'esbuild-meta.json')
  const snapshotMetaFile = path.join(snapshotCacheDir, 'snapshot-meta.json')
  const snapshotMetaPrevFile = path.join(
    snapshotCacheDir,
    'snapshot-meta.prev.json',
  )

  return {
    LOG_DEBUG,
    LOG_INFO,
    LOG_VERBOSE,

    appEntryFile,
    cypressAppSnapshotDir,
    metaFile,
    nodeModulesOnly,
    pathsMapper,
    projectBaseDir,
    snapshotCacheDir,
    snapshotEntryFile,
    snapshotMetaFile,
    snapshotMetaPrevFile,
    usePreviousSnapshotMetadata,
  }
}
